package be.uclouvain.gepiciad.sources;

import org.apache.flink.api.common.functions.RuntimeContext;
import org.apache.flink.api.common.state.ListState;
import org.apache.flink.api.common.state.ListStateDescriptor;
import org.apache.flink.runtime.state.FunctionInitializationContext;
import org.apache.flink.runtime.state.FunctionSnapshotContext;
import org.apache.flink.streaming.api.checkpoint.CheckpointedFunction;
import org.apache.flink.streaming.api.functions.source.legacy.RichParallelSourceFunction;
import org.apache.flink.util.Preconditions;
import org.apache.flink.util.StringUtils;

import java.util.*;

public class EventSource extends RichParallelSourceFunction<Event>
        implements CheckpointedFunction {
    private static final long serialVersionUID = -3986989644799442178L;

    /** Length of the artificial payload string generated for each event. */
    private final int payloadLength;

    /**
     * The size of the total key space, i.e. the number of unique keys generated by all parallel
     * sources.
     */
    private final int totalKeySpaceSize;

    /** The current event time progress of this source; will start from 0. */
    private long monotonousEventTime;

    /** This holds the key ranges for which this source generates events. */
    private transient List<KeyRangeStates> keyRanges;

    /** This is used to snapshot the state of this source, one entry per key range. */
    private transient ListState<KeyRangeStates> snapshotKeyRanges;

    /** This is used to snapshot the event time progress of the sources. */
    private transient ListState<Long> lastEventTimes;

    /** Flag that determines if this source is running, i.e. generating events. */
    private volatile boolean running;

    public EventSource(
            int totalKeySpaceSize,
            int payloadLength) {

        this.totalKeySpaceSize = totalKeySpaceSize;
        this.payloadLength = payloadLength;
        this.running = true;
    }

    @Override
    public void run(SourceContext<Event> ctx) throws Exception {
        if (keyRanges.size() > 0) {
            runActive(ctx);
        } else {
            runIdle(ctx);
        }
    }

    private void runActive(SourceContext<Event> ctx) throws Exception {
        Random random = new Random();

        // this holds the current event time, from which generated events can up to +/-
        // (maxOutOfOrder).
        while (running) {

            KeyRangeStates randomKeyRangeStates = keyRanges.get(random.nextInt(keyRanges.size()));
            int randomKey = randomKeyRangeStates.getRandomKey(random);

            // uptick the event time clock

            synchronized (ctx.getCheckpointLock()) {
                long value = randomKeyRangeStates.incrementAndGet(randomKey);

                Event event =
                        new Event(
                                randomKey,
                                0,
                                value,
                                StringUtils.getRandomString(
                                        random, payloadLength, payloadLength, 'A', 'z'));

                ctx.collect(event);
            }
        }
    }

    private void runIdle(SourceContext<Event> ctx) {
        ctx.markAsTemporarilyIdle();

        // just wait until this source is canceled
        final Object waitLock = new Object();
        while (running) {
            try {
                //noinspection SynchronizationOnLocalVariableOrMethodParameter
                synchronized (waitLock) {
                    waitLock.wait();
                }
            } catch (InterruptedException e) {
                if (!running) {
                    // restore the interrupted state, and fall through the loop
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    @Override
    public void cancel() {
        running = false;
    }

    @Override
    public void snapshotState(FunctionSnapshotContext context) throws Exception {
        snapshotKeyRanges.update(keyRanges);

        lastEventTimes.update(Collections.singletonList(monotonousEventTime));
    }

    @Override
    public void initializeState(FunctionInitializationContext context) throws Exception {
        final RuntimeContext runtimeContext = getRuntimeContext();
        final int subtaskIdx = runtimeContext.getTaskInfo().getIndexOfThisSubtask();
        final int parallelism = runtimeContext.getTaskInfo().getNumberOfParallelSubtasks();
        final int maxParallelism = runtimeContext.getTaskInfo().getMaxNumberOfParallelSubtasks();

        ListStateDescriptor<Long> unionWatermarksStateDescriptor =
                new ListStateDescriptor<>("watermarks", Long.class);

        lastEventTimes =
                context.getOperatorStateStore().getUnionListState(unionWatermarksStateDescriptor);

        ListStateDescriptor<KeyRangeStates> stateDescriptor =
                new ListStateDescriptor<>("keyRanges", KeyRangeStates.class);

        snapshotKeyRanges = context.getOperatorStateStore().getListState(stateDescriptor);
        keyRanges = new ArrayList<>();

        if (context.isRestored()) {
            // restore key ranges from the snapshot
            for (KeyRangeStates keyRange : snapshotKeyRanges.get()) {
                keyRanges.add(keyRange);
            }

            // let event time start from the max of all event time progress across subtasks in the
            // last execution
            for (Long lastEventTime : lastEventTimes.get()) {
                monotonousEventTime = Math.max(monotonousEventTime, lastEventTime);
            }
        } else {
            // determine the key ranges that belong to the subtask
            int rangeStartIdx = (subtaskIdx * maxParallelism) / parallelism;
            int rangeEndIdx = ((subtaskIdx + 1) * maxParallelism) / parallelism;

            for (int i = rangeStartIdx; i < rangeEndIdx; ++i) {

                int start = ((i * totalKeySpaceSize + maxParallelism - 1) / maxParallelism);
                int end = 1 + ((i + 1) * totalKeySpaceSize - 1) / maxParallelism;

                if (end - start > 0) {
                    keyRanges.add(new KeyRangeStates(start, end));
                }
            }

            // fresh run; start from event time o
            monotonousEventTime = 0L;
        }
    }

    /** This defines the key-range and the current sequence numbers for all keys in the range. */
    private static class KeyRangeStates {

        /** Start key of the range (inclusive). */
        final int startKey;

        /** Start key of the range (exclusive). */
        final int endKey;

        /** This array contains the current sequence number for each key in the range. */
        final long[] statesPerKey;

        KeyRangeStates(int startKey, int endKey) {
            this(startKey, endKey, new long[endKey - startKey]);
        }

        KeyRangeStates(int startKey, int endKey, long[] statesPerKey) {
            Preconditions.checkArgument(statesPerKey.length == endKey - startKey);
            this.startKey = startKey;
            this.endKey = endKey;
            this.statesPerKey = statesPerKey;
        }

        /** Increments and returns the current sequence number for the given key. */
        long incrementAndGet(int key) {
            return ++statesPerKey[key - startKey];
        }

        /** Returns a random key that belongs to this key range. */
        int getRandomKey(Random random) {
            return random.nextInt(endKey - startKey) + startKey;
        }

        @Override
        public String toString() {
            return "KeyRangeStates{"
                    + "start="
                    + startKey
                    + ", end="
                    + endKey
                    + ", statesPerKey="
                    + Arrays.toString(statesPerKey)
                    + '}';
        }
    }
}
